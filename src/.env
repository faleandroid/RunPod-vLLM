# Default Settings File
# -------------
# The default parameters, arguments and variables for your vLLM endpoint can be set here. Most of them can also be changed dynamically per cold-start via request payload
# Check [usage.md] in docs for examples.

# --------------------------
## vLLM Default Sampling Parameters - These can be overwriten dynamically on runtime in each request - see [Usage](https://github.com/davefojtik/RunPod-vLLM/blob/main/docs/usage.md)
## see https://docs.vllm.ai/en/v0.8.5.post1/api/inference_params.html for complete documentation
# -------------
VLLMSP_N=1 # Number of output sequences to return for the given prompt.
VLLMSP_BEST_OF=1 # Number of output sequences that are generated from the prompt. From these best_of sequences, the top n sequences are returned. best_of must be greater than or equal to n. This is treated as the beam width when use_beam_search is True. By default, best_of is set to n. Warning, this is only supported in V0.
VLLMSP_PRESENCE_PENALTY=0 # Float that penalizes new tokens based on whether they appear in the generated text so far. Values > 0 encourage the model to use new tokens, while values < 0 encourage the model to repeat tokens.
VLLMSP_FREQUENCY_PENALTY=0 # Float that penalizes new tokens based on their frequency in the generated text so far. Values > 0 encourage the model to use new tokens, while values < 0 encourage the model to repeat tokens.
VLLMSP_REPETITION_PENALTY=1 # Float that penalizes new tokens based on whether they appear in the prompt and the generated text so far. Values > 1 encourage the model to use new tokens, while values < 1 encourage the model to repeat tokens.
VLLMSP_TEMPERATURE=0.1 # Float that controls the randomness of the sampling. Lower values make the model more deterministic, while higher values make the model more random. Zero means greedy sampling.
VLLMSP_TOP_P=0.8 # Float that controls the cumulative probability of the top tokens to consider. Must be in (0, 1]. Set to 1 to consider all tokens.
VLLMSP_TOP_K=10 # Integer that controls the number of top tokens to consider. Set to -1 to consider all tokens.
VLLMSP_MIN_P=0 # Float that represents the minimum probability for a token to be considered, relative to the probability of the most likely token. Must be in [0, 1]. Set to 0 to disable this.
#VLLMSP_SEED=NULL # Random seed to use for the generation.
#VLLMSP_STOP=NULL # List of strings that stop the generation when they are generated. The returned output will not contain the stop strings.
#VLLMSP_STOP_TOKEN_IDS=NULL # List of tokens that stop the generation when they are generated. The returned output will contain the stop tokens unless the stop tokens are special tokens.
#VLLMSP_BAD_WORDS=NULL # List of words that are not allowed to be generated. More precisely, only the last token of a corresponding token sequence is not allowed when the next generated token can complete the sequence.
VLLMSP_INCLUDE_STOP_STR_IN_OUTPUT=false # Whether to include the stop strings in output text. Defaults to False.
VLLMSP_IGNORE_EOS=false # Whether to ignore the EOS token and continue generating tokens after the EOS token is generated.
VLLMSP_MAX_TOKENS=2000 # Maximum number of tokens to generate per output sequence. (See your model capabilities to get this information)
VLLMSP_MIN_TOKENS=1 # Minimum number of tokens to generate per output sequence before EOS or stop_token_ids can be generated
#VLLMSP_LOGPROBS=NULL # Number of log probabilities to return per output token. When set to None, no probability is returned. If set to a non-None value, the result includes the log probabilities of the specified number of most likely tokens, as well as the chosen tokens. Note that the implementation follows the OpenAI API: The API will always return the log probability of the sampled token, so there may be up to logprobs+1 elements in the response.
#VLLMSP_PROMPT_LOGPROBS=NULL # Number of log probabilities to return per prompt token.
VLLMSP_DETOKENIZE=true # Whether to detokenize the output. Defaults to True.
VLLMSP_SKIP_SPECIAL_TOKENS=true # Whether to skip special tokens in the output.
VLLMSP_SPACES_BETWEEN_SPECIAL_TOKENS=true # Whether to add spaces between special tokens in the output. Defaults to True.
#VLLMSP_LOGITS_PROCESSORS=NULL # List of functions that modify logits based on previously generated tokens, and optionally prompt tokens as a first argument.
#VLLMSP_TRUNCATE_PROMPT_TOKENS=NULL # If set to an integer k, will use only the last k tokens from the prompt (i.e., left truncation). Defaults to None (i.e., no truncation).
#VLLMSP_GUIDED_DECODING=NULL # If provided, the engine will construct a guided decoding logits processor from these parameters. Defaults to None.
#VLLMSP_LOGIT_BIAS=NULL # If provided, the engine will construct a logits processor that applies these logit biases. Defaults to None.
#VLLMSP_ALLOWED_TOKEN_IDS=NULL # If provided, the engine will construct a logits processor which only retains scores for the given token ids. Defaults to None.
#VLLMSP_EXTRA_ARGS=NULL # Arbitrary additional args, that can be used by custom sampling implementations. Not used by any in-tree sampling implementations.

# ---------------------------------------
## vLLM Engine Arguments
## see https://docs.vllm.ai/en/v0.8.5.post1/serving/engine_args.html for complete documentation
# -------------
## Named Arguments
# -------------
#VLLME_MODEL=/workspace/models/Qwen3-14B-AWQ/
VLLME_MODEL=/workspace/models/Qwen2.5-VL-7B-Instruct-AWQ/
    # Use /workspace/ for baked models or /runpod-volume/ paths for network volume folders
# Name or path of the huggingface model to use. To use already downloaded model, specify also the download_dir with the files
VLLME_TASK="generate" # The task to use the model for. Each vLLM instance only supports one task, even if the same model can be used for multiple tasks. You must specify explicitly which task to use, even when model supports a single task, since handler chooses action based on this.
    # Possible choices: auto, generate, embedding, embed, classify, score, reward, transcription
#VLLME_TOKENIZER=NULL # Name or path of the huggingface tokenizer to use. If unspecified, model name or path will be used
#VLLME_HF_CONFIG_PATH=NULL # Name or path of the huggingface config to use. If unspecified, model name or path will be used.
#VLLME_SKIP_TOKENIZER_INIT=NULL # Skip initialization of tokenizer and detokenizer. Expects valid prompt_token_ids and None for prompt from the input. The generated output will contain token ids.
VLLME_REVISION="main" # The specific model version to use. It can be a branch name, a tag name, or a commit id. If unspecified, will use the default version
#VLLME_CODE_REVISION=NULL # The specific revision to use for the model code on Hugging Face Hub. It can be a branch name, a tag name, or a commit id. If unspecified, will use the default version.
VLLME_TOKENIZER_REVISION="main" # Revision of the huggingface tokenizer to use. It can be a branch name, a tag name, or a commit id. If unspecified, will use the default version.
VLLME_TOKENIZER_MODE="auto" # Possible choices: auto, slow, mistral, custom ()
VLLME_TRUST_REMOTE_CODE=true # Trust remote code from huggingface
#VLLME_ALLOWED-LOCAL-MEDIA-PATH=NONE # Allowing API requests to read local images or videos from directories specified by the server file system. This is a security risk. Should only be enabled in trusted environments.
VLLME_CONFIG_FORMAT="auto" # Possible choices: auto, hf, mistral
VLLME_DTYPE="float16" # Data type for model weights and activations. Possible choices: auto, half, float16, bfloat16, float, float32
VLLME_MAX_MODEL_LEN=32768 # Model context length. If unspecified, will be automatically derived from the model config. Supports k/m/g/K/M/G in human-readable format. Examples: - 1k → 1000 - 1K → 1024
#VLLME_LOGITS_PROCESSOR_PATTER=NULL # Optional regex pattern specifying valid logits processor qualified names that can be passed with the logits_processors extra completion argument. Defaults to None, which allows no processors.
VLLME_MODEL_IMPL="auto" # Possible choices: auto, vllm, transformers. “auto” (default) will try to use the vLLM implementation if it exists and fall back to the Transformers implementation if no vLLM implementation is available. “vllm” will use the vLLM model implementation. “transformers” will use the Transformers model implementation.
#VLLME_DISABLE_SLIDING_WINDOW=NULL # Disables sliding window, capping to sliding window size
VLLME_SEED=0 # Random seed for operations
VLLME_MAX_LOGPROBS=20 # Max number of log probs to return logprobs is specified in SamplingParams
VLLME_DISABLE_LOG_STATS=true # Disable logging statistics
VLLME_QUANTIZATION="awq_marlin" # Method used to quantize the weights. If None, we first check the quantization_config attribute in the model config file. If that is None, we assume the model weights are not quantized and use dtype to determine the data type of the weights
    # aqlm, awq, deepspeedfp, tpu_int8, fp8, ptpc_fp8, fbgemm_fp8, modelopt, nvfp4, marlin, bitblas, gguf, gptq_marlin_24, gptq_marlin, gptq_bitblas, awq_marlin, gptq, compressed-tensors, bitsandbytes, qqq, hqq, experts_int8, neuron_quant, ipex, quark, moe_wna16, torchao, None
#VLLME_ROPE_SCALING={"type":"dynamic","factor":1.0} # RoPE scaling configuration in JSON format. For example, {“type”:”dynamic”,”factor”:2.0}
#VLLME_ROPE_THETA=NULL # RoPE theta. Use with rope_scaling. In some cases, changing the RoPE theta improves the performance of the scaled model
#VLLME_HF_TOKEN=NULL # The token to use as HTTP bearer authorization for remote files. If True, will use the token generated when running huggingface-cli login (stored in ~/.huggingface).
#VLLME_HF_OVERRIDES=NULL # Extra arguments for the HuggingFace config. This should be a JSON string that will be parsed into a dictionary.
VLLME_ENFORCE_EAGER=true # Always use eager-mode PyTorch. If False, will use eager mode and CUDA graph in hybrid for maximal performance and flexibility
VLLME_MAX_SEQ_LEN_TO_CAPTURE=32768 # Maximum sequence length covered by CUDA graphs. When a sequence has context length larger than this, we fall back to eager mode. Additionally for encoder-decoder models, if the sequence length of the encoder input is larger than this, we fall back to the eager mode
#VLLME_MM_PROCESSOR_KWARGS=NULL # Overrides for the multi-modal processor obtained from AutoProcessor.from_pretrained. The available overrides depend on the model that is being run.For example, for Phi-3-Vision: {"num_crops": 4}.
#VLLME_DISABLE_MM_PREPROCESSOR_CACHE=false # If True, disable caching of the processed multi-modal inputs.
#VLLME_IGNORE_PATTERNS=NULL # The pattern(s) to ignore when loading the model.Default to ‘original/**/*’ to avoid repeated loading of llama’s checkpoints
#VLLME_SERVED_MODEL_NAME="Qwen3-14B-AWQ" # The model name(s) used in the API. If multiple names are provided, the server will respond to any of the provided names. The model name in the model field of a response will be the first name in this list. If not specified, the model name will be the same as the –model argument. Noted that this name(s)will also be used in model_name tag content of prometheus metrics, if multiple names provided, metricstag will take the first one
VLLME_SERVED_MODEL_NAME="Qwen2.5-VL-7B-Instruct-AWQ"
#VLLME_QLORA_ADAPTER_NAME_OR_PATH=NULL # Name or path of the QLoRA adapter
#VLLME_SHOW_HIDDEN_METRICS_FOR_VERSION=NULL # Enable deprecated Prometheus metrics that have been hidden since the specified version. For example, if a previously deprecated metric has been hidden since the v0.7.0 release, you use –show-hidden-metrics-for-version=0.7 as a temporary escape hatch while you migrate to new metrics. The metric is likely to be removed completely in an upcoming release.
#VLLME_OTLP_TRACES_ENDPOINT=NULL # Target URL to which OpenTelemetry traces will be sent
#VLLME_COLLECT_DETAILED_TRACES=NULL # Valid choices are model,worker,all. It makes sense to set this only if –otlp-traces-endpoint is set. If set, it will collect detailed traces for the specified modules. This involves use of possibly costly and or blocking operations and hence might have a performance impact
#VLLME_DISABLE_ASYNC_OUTPUT_PROC=NULL # Disable async output processing. This may result in lower performance
VLLME_SCHEDULER_CLS="vllm.core.scheduler.Scheduler" # The scheduler class to use. “vllm.core.scheduler.Scheduler” is the default scheduler. Can be a class directly or the path to a class of form “mod.custom_class”.
#VLLME_OVERRIDE_NEURON_CONFIG=NULL # Override or set neuron device configuration. e.g. {“cast_logits_dtype”: “bloat16”}.’
#VLLME_OVERRIDE_POOLER_CONFIG=NULL # Override or set the pooling method for pooling models. e.g. {“pooling_type”: “mean”, “normalize”: false}.’
#VLLME_COMPILATION_CONFIG={"level": 3, "cudagraph_capture_sizes": [1,2,4,8]} # torch.compile configuration for the model. When it is a number (0, 1, 2, 3), it will be interpreted as the optimization level. NOTE: level 0 is the default level without any optimization. level 1 and 2 are for internal testing only. level 3 is the recommended level for production. To specify the full compilation config, use a JSON string, e.g. {"level": 3, "cudagraph_capture_sizes": [1, 2, 4, 8]} Following the convention of traditional compilers, using -O without space is also supported. -O3 is equivalent to -O 3.
#VLLME_KV_TRANSFER_CONFIG=NULL # The configurations for distributed KV cache transfer. Should be a JSON string.
#VLLME_WORKER_CLS="auto" # The worker class to use for distributed execution.
#VLLME_WORKER_EXTENSION_CLS="" # The worker extension class on top of the worker cls, it is useful if you just want to add new functions to the worker class without changing the existing functions.
VLLME_GENERATION_CONFIG="vllm" # The folder path to the generation config. Defaults to None, no generation config is loaded, vLLM defaults will be used. If set to ‘auto’, the generation config will be loaded from model path. If set to a folder path, the generation config will be loaded from the specified folder path. If max_new_tokens is specified in generation config, then it sets a server-wide limit on the number of output tokens for all requests.
#VLLME_OVERRIDE_GENERATION_CONFIG=NULL # Overrides or sets generation config in JSON format. e.g. {"temperature": 0.5}. If used with –generation-config=auto, the override parameters will be merged with the default config from the model. If generation-config is None, only the override parameters are used.
#VLLME_ENABLE_SLEEP_MODE=false # Enable sleep mode for the engine. (only cuda platform is supported)
#VLLME_ADDITIONAL_CONFIG=NULL # Additional config for specified platform in JSON format. Different platforms may support different configs. Make sure the configs are valid for the platform you are using. The input format is like ‘{”config_key”:”config_value”}’
#VLLME_ENABLE_REASONING=false # Whether to enable reasoning_content for the model. If enabled, the model will be able to generate reasoning content.
VLLME_DISABLE_CASCADE_ATTN=true # Disable cascade attention for V1. While cascade attention does not change the mathematical correctness, disabling it could be useful for preventing potential numerical issues. Note that even if this is set to False, cascade attention will be only used when the heuristic tells that it’s beneficial.
# -------------
## LoadConfig
# -------------
VLLME_LOAD_FORMAT="auto" # The format of the model weights to load. Default: “auto”
    # Possible choices: auto, pt, safetensors, npcache, dummy, tensorizer, sharded_state, gguf, bitsandbytes, mistral, runai_streamer, runai_streamer_sharded, fastsafetensors
#VLLME_DOWNLOAD_DIR="" # Directory to download and load the weights, default to the default cache directory of Hugging Face.
#VLLME_MODEL_LOADER_EXTRA_CONFIG=NULL # Extra config for model loader. This will be passed to the model loader corresponding to the chosen load_format. This should be a JSON string that will be parsed into a dictionary.
VLLME_use_tqdm_on_load=false # Whether to enable tqdm for showing progress bar when loading model weights. Default: True
# -------------
## DecodingConfig
# -------------
#VLLME_GUIDED_DECODING_BACKEND="auto" # Which engine will be used for guided decoding (JSON schema / regex etc) by default. With “auto”, we will make opinionated choices based on request contents and what the backend libraries currently support, so the behavior is subject to change in each release.
    # Possible choices: auto, guidance, xgrammar
VLLME_REASONING_PARSER="deepseek_r1" # Select the reasoning parser depending on the model that you’re using. This is used to parse the reasoning content into OpenAI API format. Required for --enable-reasoning.
# -------------
## ParallelConfig
# -------------
VLLME_DISTRIBUTED_EXECUTOR_BACKEND="mp" # Backend to use for distributed model workers, either “ray” or “mp” (multiprocessing). If the product of pipeline_parallel_size and tensor_parallel_size is less than or equal to the number of GPUs available, “mp” will be used to keep processing on a single host. Otherwise, this will default to “ray” if Ray is installed and fail otherwise. Note that tpu and hpu only support Ray for distributed inference.
    # Possible choices: external_launcher, mp, ray, uni, None
VLLME_PIPELINE_PARALLEL_SIZE=1 # Number of pipeline parallel groups.
VLLME_TENSOR_PARALLEL_SIZE=1 # Number of tensor parallel groups.
VLLME_DATA_PARALLEL_SIZE=1 # Number of data parallel groups. MoE layers will be sharded according to the product of the tensor parallel size and data parallel size.
VLLME_ENABLE_EXPERT_PARALLEL=false # Use expert parallelism instead of tensor parallelism for MoE layers.
#VLLME_MAX_PARALLEL_LOADING_WORKERS= # Maximum number of parallal loading workers when loading model sequentially in multiple batches. To avoid RAM OOM when using tensor parallel and large models.
#VLLME_RAY_WORKERS_USE_NSIGHT=false # Whether to profile Ray workers with nsight, see https://docs.ray.io/en/latest/ray-observability/user-guides/profiling.html#profiling-nsight-profiler.
#VLLME_DISABLE_CUSTOM_ALL_REDUCE=false # Disable the custom all-reduce kernel and fall back to NCCL.
# -------------
## CacheConfig
# -------------
VLLME_BLOCK_SIZE=32 # Size of a contiguous cache block in number of tokens. This is ignored on neuron devices and set to --max-model-len. On CUDA devices, only block sizes up to 32 are supported. On HPU devices, block size defaults to 128. This config has no static default. If left unspecified by the user, it will be set in Platform.check_and_update_configs() based on the current platform.
    # Possible choices: 1, 8, 16, 32, 64, 128
VLLME_GPU_MEMORY_UTILIZATION=0.99 # The fraction of GPU memory to be used for the model executor, which can range from 0 to 1. For example, a value of 0.5 would imply 50% GPU memory utilization. If unspecified, will use the default value of 0.9. This is a per-instance limit, and only applies to the current vLLM instance. It does not matter if you have another vLLM instance running on the same GPU. For example, if you have two vLLM instances running on the same GPU, you can set the GPU memory utilization to 0.5 for each instance.
VLLME_SWAP_SPACE=0 # Size of the CPU swap space per GPU (in GiB).
VLLME_KV_CACHE_DTYPE="auto" # Data type for kv cache storage. If “auto”, will use model data type. CUDA 11.8+ supports fp8 (=fp8_e4m3) and fp8_e5m2. ROCm (AMD GPU) supports fp8 (=fp8_e4m3).
    # Possible choices: auto, fp8, fp8_e4m3, fp8_e5m2
#VLLME_NUM_GPU_BLOCKS_OVERRIDE=0 # Number of GPU blocks to use. This overrides the profiled num_gpu_blocks if specified. Does nothing if None. Used for testing preemption.
VLLME_ENABLE_PREFIX_CACHING=true # Whether to enable prefix caching. Disabled by default for V0. Enabled by default for V1.
VLLME_PREFIX_CACHING_HASH_ALGO="builtin" # Set the hash algorithm for prefix caching: “builtin” is Python’s built-in hash. “sha256” is collision resistant but with certain overheads.
    # Possible choices: builtin, sha256
VLLME_CPU_OFFLOAD_GB=0 # The space in GiB to offload to CPU, per GPU. Default is 0, which means no offloading. Intuitively, this argument can be seen as a virtual way to increase the GPU memory size. For example, if you have one 24 GB GPU and set this to 10, virtually you can think of it as a 34 GB GPU. Then you can load a 13B model with BF16 weight, which requires at least 26GB GPU memory. Note that this requires fast CPU-GPU interconnect, as part of the model is loaded from CPU memory to GPU memory on the fly in each model forward pass.
VLLME_CALCULATE_KV_SCALES=false # This enables dynamic calculation of k_scale and v_scale when kv_cache_dtype is fp8. If False, the scales will be loaded from the model checkpoint if available. Otherwise, the scales will default to 1.0. Default: False
# -------------
## MultiModalConfig
# -------------
VLLME_LIMIT_MM_PER_PROMPT={"images": 4, "videos": 0} # The maximum number of input items allowed per prompt for each modality. This should be a JSON string that will be parsed into a dictionary. Defaults to 1 (V0) or 999 (V1) for each modality. For example, to allow up to 16 images and 2 videos per prompt: {"images": 16, "videos": 2}
# -------------
## LoRAConfig
# -------------
VLLME_ENABLE_LORA=false # If True, enable handling of LoRA adapters.
VLLME_ENABLE_LORA_BIAS=false # Enable bias for LoRA adapters.
VLLME_MAX_LORAS=1 # Max number of LoRAs in a single batch.
VLLME_MAX_LORA_RANK=16 # Max LoRA rank.
VLLME_LORA_EXTRA_VOCAB_SIZE=256 # Maximum size of extra vocabulary that can be present in a LoRA adapter (added to the base model vocabulary).
VLLME_LORA_DTYPE="auto" # Data type for LoRA. If auto, will default to base model dtype.
    # Possible choices: auto, bfloat16, float16
#VLLME_LONG_LORA_SCALING_FACTORS= # Specify multiple scaling factors (which can be different from base model scaling factor - see eg. Long LoRA) to allow for multiple LoRA adapters trained with those scaling factors to be used at the same time. If not specified, only adapters trained with the base model scaling factor are allowed.
VLLME_MAX_CPU_LORAS=1 # Maximum number of LoRAs to store in CPU memory. Must be >= than max_loras.
VLLME_FULLY_SHARDED_LORAS=false # By default, only half of the LoRA computation is sharded with tensor parallelism. Enabling this will use the fully sharded layers. At high sequence length, max rank or tensor parallel size, this is likely faster.
# -------------
## PromptAdapterConfig
# -------------
#VLLME_ENABLE_PROMPT_ADAPTER=false # If True, enable handling of PromptAdapters.
#VLLME_max_prompt_adapters=1 # Max number of PromptAdapters in a batch.
#VLLME_MAX_PROMPT_ADAPTER_TOKEN=0 # Max number of PromptAdapters tokens.
# -------------
## DeviceConfig
# -------------
#VLLME_DEVICE="cuda" # Device type for vLLM execution.
    # Possible choices: auto, cpu, cuda, hpu, neuron, tpu, xpu
# -------------
## SpeculativeConfig
# -------------
#VLLME_SPECULATIVE_CONFIG="{}" # The configurations for speculative decoding. Should be a JSON string.
# -------------
## SchedulerConfig
# -------------
VLLME_MAX_NUM_BATCHED_TOKENS=16384 # Maximum number of tokens to be processed in a single iteration. This config has no static default. If left unspecified by the user, it will be set in EngineArgs.create_engine_config based on the usage context.
VLLME_MAX_NUM_SEQS=256 # Maximum number of sequences to be processed in a single iteration. This config has no static default. If left unspecified by the user, it will be set in EngineArgs.create_engine_config based on the usage context.
VLLME_MAX_NUM_PARTIAL_PREFILLS=1 # For chunked prefill, the maximum number of sequences that can be partially prefilled concurrently.
VLLME_MAX_LONG_PARTIAL_PREFILLS=1 # For chunked prefill, the maximum number of prompts longer than long_prefill_token_threshold that will be prefilled concurrently. Setting this less than max_num_partial_prefills will allow shorter prompts to jump the queue in front of longer prompts in some cases, improving latency.
#VLLME_LONG_PREFILL_TOKEN_THRESHOLD=0 # For chunked prefill, a request is considered long if the prompt is longer than this number of tokens.
VLLME_NUM_LOOKAHEAD_SLOTS=0 # The number of slots to allocate per sequence per step, beyond the known token ids. This is used in speculative decoding to store KV activations of tokens which may or may not be accepted. NOTE: This will be replaced by speculative config in the future; it is present to enable correctness tests until then.
VLLME_SCHEDULER_DELAY_FACTOR=0.0 # Apply a delay (of delay factor multiplied by previous prompt latency) before scheduling next prompt.
#VLLME_PREEMPTION_MODE="recompute" # Whether to perform preemption by swapping or recomputation. If not specified, we determine the mode as follows: We use recomputation by default since it incurs lower overhead than swapping. However, when the sequence group has multiple sequences (e.g., beam search), recomputation is not currently supported. In such a case, we use swapping instead.
    # Possible choices: recompute, swap, None
VLLME_NUM_SCHEDULER_STEPS=1 # Maximum number of forward steps per scheduler call.
VLLME_MULTI_STEP_STREAM_OUTPUTS=true # If False, then multi-step will stream outputs at the end of all steps
VLLME_SCHEDULING_POLICY="fcfs" # The scheduling policy to use: “fcfs” means first come first served, i.e. requests are handled in order of arrival. “priority” means requests are handled based on given priority (lower value means earlier handling) and time of arrival deciding any ties). Default: “fcfs”
    # Possible choices: fcfs, priority
VLLME_ENABLE_CHUNKED_PREFILL=true # If True, prefill requests can be chunked based on the remaining max_num_batched_tokens.
VLLME_DISABLE_CHUNKED_MM_INPUT=false # If set to true and chunked prefill is enabled, we do not want to partially schedule a multimodal item. Only used in V1 This ensures that if a request has a mixed prompt (like text tokens TTTT followed by image tokens IIIIIIIIII) where only some image tokens can be scheduled (like TTTTIIIII, leaving IIIII), it will be scheduled as TTTT in one step and IIIIIIIIII in the next. Default: False

# ---------------------------------------
## vLLM Enviroment Variables
## see https://docs.vllm.ai/en/v0.8.5.post1/serving/env_vars.html for complete documentation
# -------------
VLLM_CACHE_ROOT="/home/root/.cache/vllm" # Root directory for VLLM cache files
    # You don't have to manually set this to network volume. If VLLMC_AUTO_NETWORK_CACHE is set to true, this is set to the network path automatically on runtime.
#VLLM_HOST_IP="127.0.0.1" # used in distributed environment to determine the ip address of the node
VLLM_PORT=8000 # used in distributed environment to manually set the communication port
VLLM_RPC_BASE_PATH="/tmp" # path used for ipc when the frontend api server is running in multi-processing mode to communicate with the backend engine process
VLLM_USE_MODELSCOPE=false # If true, will load models from ModelScope instead of Hugging Face Hub
VLLM_RINGBUFFER_WARNING_INTERVAL=60 # Interval in seconds to log a warning message when the ring buffer is full
#CUDA_HOME=NULL # path to cudatoolkit home directory, under which should be bin, include, and lib directories
#VLLM_NCCL_SO_PATH=NULL # Path to the NCCL library file. It is needed because nccl>=2.19 brought by PyTorch contains a bug: https://github.com/NVIDIA/nccl/issues/1234
#LD_LIBRARY_PATH=NULL  # when `VLLM_NCCL_SO_PATH` is not set, vllm will try to find the nccl library file in the locations specified by `LD_LIBRARY_PATH`
VLLM_USE_TRITON_FLASH_ATTN=true # flag to control if vllm should use triton flash attention
#VLLM_FLASH_ATTN_VERSION=NULL # Force vllm to use a specific flash-attention version (2 or 3), only valid when using the flash-attention backend.
VLLM_TEST_DYNAMO_FULLGRAPH_CAPTURE=false # Internal flag to enable Dynamo fullgraph capture
LOCAL_RANK=0 # local rank of the process in the distributed setting, used to determine the GPU device id
#CUDA_VISIBLE_DEVICES=NULL # used to control the visible devices in the distributed setting
VLLM_ENGINE_ITERATION_TIMEOUT_S=60 # timeout for each iteration in the engine
#VLLM_API_KEY=NULL # API key for VLLM API server
VLLM_DEBUG_LOG_API_SERVER_RESPONSE=false # Whether to log responses from API Server for debugging

# S3 access information, used for tensorizer to load model from S3
#S3_ACCESS_KEY_ID=NULL 
#S3_SECRET_ACCESS_KEY=NULL 
#S3_ENDPOINT_URL=NULL 

# Usage stats collection
VLLM_USAGE_STATS_SERVER=""
VLLM_NO_USAGE_STATS=true
VLLM_DO_NOT_TRACK=true
VLLM_USAGE_SOURCE="production"

# Logging configuration. If set to 0, vllm will not configure logging. If set to 1, vllm will configure logging using the default configuration or the configuration file specified by VLLM_LOGGING_CONFIG_PATH
VLLM_CONFIGURE_LOGGING=0
#VLLM_LOGGING_CONFIG_PATH=NULL
VLLM_LOGGING_LEVEL="INFO"
#VLLM_LOGGING_PREFIX="" # if set, VLLM_LOGGING_PREFIX will be prepended to all log messages
#VLLM_LOGITS_PROCESSOR_THREADS=0 # if set, vllm will call logits processors in a thread pool with this many threads. This is useful when using custom logits processors that either (a) launch additional CUDA kernels or (b) do significant CPU-bound work while not holding the python GIL, or both.
VLLM_TRACE_FUNCTION=0 # Trace function calls. If set to 1, vllm will trace function calls. Useful for debugging

VLLM_ATTENTION_BACKEND="FLASH_ATTN" # Backend for attention computation. Available options:
    # - "TORCH_SDPA": use torch.nn.MultiheadAttention
    # - "FLASH_ATTN": use FlashAttention
    # - "XFORMERS": use XFormers
    # - "ROCM_FLASH": use ROCmFlashAttention
    # - "FLASHINFER": use flashinfer
    # - "FLASHMLA": use FlashMLA
VLLM_USE_FLASHINFER_SAMPLER=1 # If set, vllm will use flashinfer sampler
#VLLM_FLASHINFER_FORCE_TENSOR_CORES=0 # If set, vllm will force flashinfer to use tensor cores; otherwise will use heuristic based on model architecture.
#VLLM_PP_LAYER_PARTITION=24 # Pipeline stage partition strategy (You need to know the amount of hidden layers of your model to set this manually)
VLLM_CPU_KVCACHE_SPACE=0 # (CPU backend only) CPU key-value cache space. default is 4GB
VLLM_CPU_OMP_THREADS_BIND="all" # (CPU backend only) CPU core ids bound by OpenMP threads, e.g., "0-31", "0,1,2", "0-31,33". CPU cores of different ranks are separated by '|'.
# VLLM_CPU_MOE_PREPACK=0 # (CPU backend only) whether to use prepack for MoE layer. This will be passed to ipex.llm.modules.GatedMLPMOE. On unsupported CPUs, you might need to set this to "0" (False).
#VLLM_USE_RAY_SPMD_WORKER=0 # If the env var is set, then all workers will execute as separate processes from the engine, and we use the same mechanism to trigger execution on all workers. Run vLLM with VLLM_USE_RAY_SPMD_WORKER=1 to enable it.
#VLLM_USE_RAY_COMPILED_DAG=0 # If the env var is set, it uses the Ray's compiled DAG API which optimizes the control plane overhead. Run vLLM with VLLM_USE_RAY_COMPILED_DAG=1 to enable it.
#VLLM_USE_RAY_COMPILED_DAG_CHANNEL_TYPE=true # If the env var is set, Ray Compiled Graph uses the specified channel type to communicate between workers belonging to different pipeline-parallel stages.
    # Available options:"auto", "nccl", "shm": use shared memory and gRPC for communication
#VLLM_USE_RAY_COMPILED_DAG_OVERLAP_COMM=true # If the env var is set, it enables GPU communication overlap in Ray's compiled DAG. This flag is ignored if VLLM_USE_RAY_COMPILED_DAG is not set.
VLLM_WORKER_MULTIPROC_METHOD="spawn" # Use dedicated multiprocess context for workers. Both spawn and fork work
VLLM_ASSETS_CACHE="/home/root/.cache/vllm/assets" # Path to the cache for storing downloaded assets
VLLM_IMAGE_FETCH_TIMEOUT=5 # Timeout for fetching images when serving multimodal models. Default is 5 seconds
VLLM_VIDEO_FETCH_TIMEOUT=15 # # Timeout for fetching videos when serving multimodal models. Default is 15 seconds
VLLM_AUDIO_FETCH_TIMEOUT=10 # Timeout for fetching audio when serving multimodal models. Default is 10 seconds
VLLM_MM_INPUT_CACHE_SIZE=4 # # Cache size (in GiB) for multimodal input cache
VLLM_XLA_CACHE_PATH="/home/root/.cache/vllm/xla_cache" # Path to the XLA persistent cache directory. Only used for XLA devices such as TPUs.
VLLM_FUSED_MOE_CHUNK_SIZE=32768
VLLM_NO_DEPRECATION_WARNING=false # If set, vllm will skip the deprecation warnings.
VLLM_KEEP_ALIVE_ON_ENGINE_DEATH=false # If set, the OpenAI API server will stay alive even after the underlying. AsyncLLMEngine errors and stops serving requests
VLLM_ALLOW_LONG_MAX_MODEL_LEN=1 # If the env var VLLM_ALLOW_LONG_MAX_MODEL_LEN is set, it allows the user to specify a max sequence length greater than the max length derived from the model's config.json. To enable this, set VLLM_ALLOW_LONG_MAX_MODEL_LEN=1.
VLLM_TEST_FORCE_FP8_MARLIN=0 # If set, forces FP8 Marlin to be used for FP8 quantization regardless of the hardware support for FP8 compute.
#VLLM_TEST_FORCE_LOAD_FORMAT= "dummy" #
VLLM_RPC_TIMEOUT=10000 # Time in ms for the zmq client to wait for a response from the backend server for simple data operations
#VLLM_PLUGINS=NULL # a list of plugin names to load, separated by commas. if this is not set, it means all plugins will be loaded. if this is set to an empty string, no plugins will be loaded
#VLLM_TORCH_PROFILER_DIR=NULL  # Enables torch profiler if set. Path to the directory where torch profiler traces are saved. Note that it must be an absolute path.
VLLM_USE_TRITON_AWQ=1 # If set, vLLM will use Triton implementations of AWQ.
VLLM_ALLOW_RUNTIME_LORA_UPDATING=false # If set, allow loading or unloading lora adapters in runtime
VLLM_SKIP_P2P_CHECK=1 # By default, vLLM will check the peer-to-peer capability itself, # in case of broken drivers. See https://github.com/vllm-project/vllm/blob/a9b15c606fea67a072416ea0ea115261a2756058/vllm/distributed/device_communicators/custom_all_reduce_utils.py#L101-L108 for details. # noqa
    # If this env var is set to 1, vLLM will skip the peer-to-peer check, and trust the driver's peer-to-peer capability report.
#VLLM_DISABLED_KERNELS=[] # # List of quantization kernels that should be disabled, used for testing and performance comparisons. Currently only affects MPLinearKernel selection (kernels: MacheteLinearKernel, MarlinLinearKernel, ExllamaLinearKernel)
#VLLM_USE_V1=false # If set, use the V1 code path.

#VLLM_ROCM_USE_AITER=false # Disable aiter ops unless specifically enabled. Acts as a parent switch to enable the rest of the other operations.
#VLLM_ROCM_USE_AITER_PAGED_ATTN=false # Whether to use aiter paged attention. By default is disabled.
#VLLM_ROCM_USE_AITER_LINEAR=true # Use aiter linear op if aiter ops are enabled. The following list of related ops - scaled_mm (per-tensor / rowwise)
#VLLM_ROCM_USE_AITER_MOE=false # Whether to use aiter moe ops. By default is enabled.
#VLLM_ROCM_USE_AITER_RMSNORM=true # use aiter rms norm op if aiter ops are enabled.
#VLLM_ROCM_USE_AITER_MLA=true # Whether to use aiter mla ops. By default is enabled.
#VLLM_ROCM_USE_SKINNY_GEMM=true # Use rocm skinny gemms
#VLLM_ROCM_FP8_PADDING=1 # Pad the fp8 weights to 256 bytes for ROCm
#VLLM_ROCM_MOE_PADDING=1 # Pad the weights for the moe kernel
#VLLM_ROCM_CUSTOM_PAGED_ATTN=1  # Custom paged attention kernel for MI3* cards
#Q_SCALE_CONSTANT="200" # Divisor for dynamic query scale factor calculation for FP8 KV Cache
#VLLM_K_SCALE_CONSTANT=200 # Divisor for dynamic key scale factor calculation for FP8 KV Cache
#VLLM_V_SCALE_CONSTANT=100 # Divisor for dynamic value scale factor calculation for FP8 KV Cache
#VLLM_ENABLE_V1_MULTIPROCESSING=true # # If set, enable multiprocessing in LLM for the V1 code path.
#VLLM_LOG_BATCHSIZE_INTERVAL=-1
VLLM_DISABLE_COMPILE_CACHE=0 # Disable the torch.compile optimalization, to turn off torch.compile completely, see the variale below
TORCHDYNAMO_DISABLE=0 # Prevent Dynamo from performing bytecode transformations, effectively bypassing the whole torch.compile process.
#VLLM_V1_OUTPUT_PROC_CHUNK_SIZE=128 # Controls the maximum number of requests to handle in a single asyncio task when processing per-token outputs in the V1 AsyncLLM interface. It is applicable when handling a high concurrency of streaming requests. Setting this too high can result in a higher variance of inter-message latencies. Setting it too low can negatively impact TTFT and overall throughput.
VLLM_MLA_DISABLE=1 # If set, vLLM will disable the MLA attention optimizations.
VLLM_USE_V1=1 # Use older (but faster to startup) inference engine
#VLLM_ENABLE_MOE_ALIGN_BLOCK_SIZE_TRITON="false" # # If set, vLLM will use the Triton implementation of moe_align_block_size, i.e. moe_align_block_size_triton in fused_moe.py.
#VLLM_RAY_PER_WORKER_GPUS=1.0 # Number of GPUs per worker in Ray, if it is set to be a fraction, it allows ray to schedule multiple actors on a single GPU, so that users can colocate other actors on the same GPUs as vLLM.
#VLLM_RAY_BUNDLE_INDICES="" # Bundle indices for Ray, if it is set, it can control precisely which indices are used for the Ray bundle, for every worker. Format: comma-separated list of integers, e.g. "0,1,2,3"
#VLLM_CUDART_SO_PATH=NULL # In some system, find_loaded_library() may not work. So we allow users to specify the path through environment variable VLLM_CUDART_SO_PATH.
#VLLM_USE_HPU_CONTIGUOUS_CACHE_FETCH=NULL # Contiguous cache fetching to avoid using costly gather operation on Gaudi3. This is only applicable to HPU contiguous cache. If set to true, contiguous cache fetch will be used.
#VLLM_HPU_USE_DELAYED_SAMPLING=true # Use delayed sampling for HPU to reduce host cpu overhead between each step.
#VLLM_DP_RANK=0 # Rank of the process in the data parallel setting
#VLLM_DP_RANK_LOCAL=NULL # Rank of the process in the data parallel setting. Defaults to VLLM_DP_RANK when not set.
#VLLM_DP_SIZE=1 # World size of the data parallel setting
#VLLM_DP_MASTER_IP="127.0.0.1" # IP address of the master node in the data parallel setting
#VLLM_DP_MASTER_PORT="0" # Port of the master node in the data parallel setting
#VLLM_CI_USE_S3=0 # Whether to use S3 path for model loading in CI via RunAI Streamer
#VLLM_MODEL_REDIRECT_PATH=NULL # Use model_redirect to redirect the model name to a local folder. `model_redirect` can be a json file mapping the model between repo_id and local folder: {"meta-llama/Llama-3.2-1B": "/tmp/Llama-3.2-1B"} or a space separated values table file: meta-llama/Llama-3.2-1B   /tmp/Llama-3.2-1B
VLLM_MARLIN_USE_ATOMIC_ADD=1 # Whether to use atomicAdd reduce in gptq/awq marlin kernel.
#VLLM_V0_USE_OUTLINES_CACH=0  # Whether to turn on the outlines cache for V0. This cache is unbounded and on disk, so it's not safe to use in an environment with potentially malicious users.
#VLLM_TPU_BUCKET_PADDING_GAP=0 # Gap between padding buckets for the forward pass. So we have 8, we will run forward pass with [16, 24, 32, ...].
#VLLM_USE_DEEP_GEMM=false # Allow use of DeepGemm kernels for fused moe ops.
VLLM_XGRAMMAR_CACHE_MB=512 # Control the cache sized used by the xgrammar compiler. The default of 512 MB should be enough for roughly 1000 JSON schemas. It can be changed with this variable if needed for some reason.
VLLM_MSGPACK_ZERO_COPY_THRESHOLD=256 # # Control the threshold for msgspec to use 'zero copy' for serialization/deserialization of tensors. Tensors below this limit will be encoded into the msgpack buffer, and tensors above will instead be sent via a separate message. While the sending side still actually copies the tensor in all cases, on the receiving side, tensors above this limit will actually be zero-copy decoded. 

# ---------------------------------------
## RunPod Enviroment Variables
## see https://docs.runpod.io/serverless/workers/vllm/environment-variables for complete documentation
# -------------
DISABLE_LOG_STATS=true # Enables or disables vLLM stats logging
DISABLE_LOG_REQUESTS=true # Enables or disables vLLM request logging.

## OpenAI Settings
RAW_OPENAI_OUTPUT=0 # Enables raw OpenAI SSE format string output when streaming. Required to be enabled (which it is by default) for OpenAI compatibility. Possible choices: 0 (true) / 1 (false)
OPENAI_SERVED_MODEL_NAME_OVERRIDE="Qwen2.5-VL-7B-Instruct-AWQ" # Overrides the name of the served model from model repo/path to specified name, which you will then be able to use as the value for the model parameter when making OpenAI requests
OPENAI_RESPONSE_ROLE="assistant" # Role of the LLM's Response in OpenAI Chat Completions.
#LORA_ADAPTERS={"name":"", "path":"", "base_model_name":""} # Specify LORAs to be used with the model
OPENAI_STREAM_BATCH_SIZE=50 # Default size of tokens batch to send in one stream response. Batching helps reduce http overhead and amount of updates in your frontend chat UI.
OPENAI_STREAM_MIN_BATCH_SIZE=1 # Minimal size of tokens batch to send in one stream response. Ensures that batch size never drops below a minimum value, when batch sizes shrink due to workload fluctuations.
OPENAI_STREAM_BATCH_SIZE_GROWTH_FACTOR=3 # Batch size is dynamic and somehow tries to adapt based on how fast the inference is going. This controls how fast the batch size shrinks when load decreases.

# ---------------------------------------
## Additional Custom Settings
# -------------
VLLMC_ENABLE_AUTO_TOOL_CHOICE=0 # Enable model's function/tool calling parsing (this should be disabled on models that are not capable of tool calling, or if you don't want to use it, to speed things up)
VLLMC_TOOL_CALL_PARSER='hermes' # Name of the tool calling parser. Each model should be trained on specific tool calling format, so check which one your model supports. Possible choices are:
    # hermes, mistral, llama, granite, internlm, jamba and pythonic
#VLLMC_CUSTOM_CHAT_TEMPLATE="" # String formatted chat template to use instead of the one provided in the model.
VLLMC_AUTO_NETWORK_CACHE=true # Boolean to control whether the handler should automatically detect network volume and compile and use the torch.compile cache there. 
    # If true, the cache will be computed and used only when the network volume path is detected AND the VLLM_DISABLE_COMPILE_CACHE + TORCHDYNAMO_DISABLE variables are set to false (0). Otherwise (without network volume detected), the torch.compile will be completely disabled (same as TORCHDYNAMO_DISABLE=0).
    # If false, the values set in VLLM_DISABLE_COMPILE_CACHE and TORCHDYNAMO_DISABLE will be used no matter the network volume presence
